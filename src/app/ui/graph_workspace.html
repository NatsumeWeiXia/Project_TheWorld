<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Graph Workspace | TheWorld</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        .workspace { height: 100vh; overflow: hidden; }
        .cy-container { position: relative; height: calc(100vh - 48px); background: radial-gradient(circle at 20% 20%, #eff6ff 0%, #f8fafc 35%, #f1f5f9 100%); }
        [data-theme="dark"] .cy-container { background: radial-gradient(circle at 20% 20%, #111827 0%, #0b1220 35%, #0f172a 100%); }
        #cy { width: 100%; height: 100%; }
        .tree-node { margin-left: 1rem; border-left: 1px solid #cbd5e1; padding-left: 0.5rem; }
        [data-theme="dark"] .tree-node { border-left-color: #334155; }
        .tooltip-box { position: absolute; z-index: 50; pointer-events: none; max-width: 360px; }
        .sidebar-section { display: flex; flex-direction: column; overflow: hidden; transition: flex 0.3s ease; }
        .sidebar-section.expanded { flex: 1; }
        .sidebar-section.collapsed { flex: 0 0 auto; }
    </style>
</head>
<body class="bg-base-100 text-base-content antialiased">
<div id="app" v-cloak class="workspace flex flex-col">
    <header class="h-12 border-b flex items-center justify-between px-4 bg-base-100 z-30 shadow-sm shrink-0">
        <div class="flex items-center gap-3">
            <span class="font-bold text-lg flex items-center gap-2">
                <i class="fas fa-project-diagram text-primary"></i> TheWorld <span class="text-xs opacity-50 font-mono">Graph</span>
            </span>
            <div class="divider divider-horizontal m-0"></div>
            <div class="flex gap-2">
                <input v-model="config.tenantId" class="input input-xs input-bordered w-32" placeholder="Tenant ID" />
                <input v-model="config.token" type="password" class="input input-xs input-bordered w-32" placeholder="Token" />
            </div>
        </div>
        <div class="flex items-center gap-2">
            <button class="btn btn-xs btn-ghost" @click="toggleTheme">{{ isDarkTheme ? "Light" : "Dark" }}</button>
            <button class="btn btn-xs btn-outline" @click="reloadResources">Reload</button>
            <button class="btn btn-xs btn-outline" @click="fitGraph">Fit</button>
            <button class="btn btn-xs btn-outline" @click="clearGraph">Clear</button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <aside class="w-[400px] border-r bg-base-200 shrink-0 flex flex-col overflow-hidden">
            <!-- Data Attributes Section -->
            <div class="sidebar-section border-b" :class="sections.dataAttributes ? 'expanded' : 'collapsed'">
                <div class="flex items-center justify-between px-4 py-2 bg-base-300 cursor-pointer" @click="sections.dataAttributes = !sections.dataAttributes">
                    <span class="font-bold text-sm flex items-center gap-2">
                        <i class="fas" :class="sections.dataAttributes ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                        Data Attributes
                    </span>
                    <span class="badge badge-sm opacity-50">{{ filteredDataAttributes.length }}</span>
                </div>
                <div v-show="sections.dataAttributes" class="flex-1 flex flex-col p-3 gap-2 overflow-hidden bg-base-100">
                    <div class="flex gap-1 shrink-0">
                        <input v-model="search.dataAttributes" class="input input-sm input-bordered flex-1" placeholder="Search by name/code" />
                        <button class="btn btn-sm btn-outline" @click="searchDataAttributes">Search</button>
                    </div>
                    <div class="flex-1 overflow-auto space-y-1 pr-1">
                        <div v-for="item in filteredDataAttributes" :key="'attr-'+item.code" class="flex items-center justify-between px-2 py-1 rounded hover:bg-base-200 group">
                            <button class="text-left flex-1 truncate" @click="openDetailModal('dataAttribute', item)">
                                <span class="font-semibold text-xs">{{ item.name }}</span>
                                <span class="text-[10px] opacity-60 ml-1 font-mono">{{ item.code }}</span>
                            </button>
                            <button class="btn btn-xs btn-primary opacity-0 group-hover:opacity-100 h-6 min-h-0 px-2" @click.stop="addResourceToGraph('dataAttribute', item)">Add</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ontologies Section -->
            <div class="sidebar-section" :class="sections.ontologies ? 'expanded' : 'collapsed'">
                <div class="flex items-center justify-between px-4 py-2 bg-base-300 cursor-pointer" @click="sections.ontologies = !sections.ontologies">
                    <span class="font-bold text-sm flex items-center gap-2">
                        <i class="fas" :class="sections.ontologies ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                        Ontologies
                    </span>
                    <span class="badge badge-sm opacity-50">{{ ontologies.length }}</span>
                </div>
                <div v-show="sections.ontologies" class="flex-1 flex flex-col p-3 gap-2 overflow-hidden bg-base-100">
                    <div class="flex gap-1 shrink-0">
                        <input v-model="search.ontologies" class="input input-sm input-bordered flex-1" placeholder="Search by name/code" />
                        <button class="btn btn-sm btn-outline" @click="searchOntologies">Search</button>
                    </div>
                    <div class="flex-1 overflow-auto pr-1">
                        <div v-for="node in filteredOntologyTree" :key="'tree-root-'+node.code">
                            <ontology-tree-item 
                                :node="node" 
                                @add="addResourceToGraph('ontology', $event)" 
                                @detail="openDetailModal('ontology', $event)">
                            </ontology-tree-item>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <section class="flex-1 cy-container">
            <div id="cy"></div>
            <div ref="tooltip" class="tooltip tooltip-open tooltip-right tooltip-box hidden">
                <div class="tooltip-content bg-base-300 text-base-content rounded px-2 py-1 text-xs"></div>
            </div>
        </section>
    </div>

    <dialog class="modal" :class="{ 'modal-open': detailModal.open }">
        <div class="modal-box max-w-3xl">
            <h3 class="font-bold text-lg">{{ detailModal.title }}</h3>
            <p class="text-xs opacity-60 mb-3">{{ detailModal.code }}</p>
            <div v-if="detailModal.loading" class="py-8 text-center"><span class="loading loading-spinner loading-md"></span></div>
            <div v-else class="space-y-3">
                <div class="p-3 rounded bg-base-200 overflow-auto text-sm">
                    <pre>{{ prettyDetail }}</pre>
                </div>
                <div class="modal-action">
                    <button class="btn btn-primary" @click="addFromModal">Add to Graph</button>
                    <button class="btn" @click="closeDetailModal">Close</button>
                </div>
            </div>
        </div>
    </dialog>
</div>

<script>
const { createApp, ref, reactive, computed, onMounted } = Vue;

const OntologyTreeItem = {
    name: 'OntologyTreeItem',
    props: ['node'],
    emits: ['add', 'detail'],
    setup(props) {
        const expanded = ref(false);
        return { expanded };
    },
    template: `
        <div class="select-none">
            <div class="flex items-center justify-between group px-1 py-0.5 rounded hover:bg-base-200 transition-colors">
                <div class="flex items-center gap-1 flex-1 min-w-0">
                    <button v-if="node.children && node.children.length" @click.stop="expanded = !expanded" class="w-4 h-4 flex items-center justify-center opacity-50 hover:opacity-100">
                        <i class="fas fa-xs" :class="expanded ? 'fa-minus-square' : 'fa-plus-square'"></i>
                    </button>
                    <span v-else class="w-4"></span>
                    <button class="text-left flex-1 truncate" @click="$emit('detail', node)">
                        <span class="font-semibold text-xs">{{ node.name }}</span>
                        <span class="text-[10px] opacity-50 ml-1 font-mono">{{ node.code }}</span>
                    </button>
                </div>
                <button class="btn btn-xs btn-primary opacity-0 group-hover:opacity-100 h-6 min-h-0 px-2" @click.stop="$emit('add', node)">Add</button>
            </div>
            <div v-if="expanded && node.children && node.children.length" class="tree-node">
                <ontology-tree-item v-for="child in node.children" :key="child.code" :node="child" @add="$emit('add', $event)" @detail="$emit('detail', $event)"></ontology-tree-item>
            </div>
        </div>
    `
};

createApp({
    components: { OntologyTreeItem },
    setup() {
        const theme = ref(localStorage.getItem("uiTheme") || "light");
        const isDarkTheme = computed(() => theme.value === "dark");
        const config = reactive({
            tenantId: localStorage.getItem("tenantId") || "tenant-a",
            token: localStorage.getItem("token") || "test-token",
        });

        const sections = reactive({ dataAttributes: true, ontologies: true });
        const search = reactive({ dataAttributes: "", ontologies: "" });
        const dataAttributes = ref([]);
        const ontologies = ref([]);
        const detailModal = reactive({ open: false, loading: false, type: "", title: "", code: "", basic: null, detail: null });

        const requestCache = new Map();
        const detailCache = new Map();
        const ontologyRelatedCache = new Map();
        const attributeOntologyCache = new Map();

        let cy = null;
        const graphNodes = new Map();
        const graphEdges = new Map();
        const tooltip = ref(null);
        let tapState = { id: "", ts: 0 };
        let tapTimer = null;

        const nodeConfig = {
            ontology: { shape: "roundrectangle", color: "#3b82f6", width: 220, height: 74, fontSize: 13, textMaxWidth: 170, borderWidth: 4 },
            dataAttribute: { shape: "ellipse", color: "#f59e0b", width: 72, height: 72, fontSize: 8, textMaxWidth: 80, borderWidth: 2 },
            objectProperty: { shape: "diamond", color: "#8b5cf6", width: 68, height: 68, fontSize: 8, textMaxWidth: 76, borderWidth: 2 },
            capability: { shape: "hexagon", color: "#ef4444", width: 68, height: 68, fontSize: 8, textMaxWidth: 76, borderWidth: 2 },
        };

        const prettyDetail = computed(() => JSON.stringify(detailModal.detail || {}, null, 2));

        const filteredDataAttributes = computed(() => {
            return dataAttributes.value;
        });

        const ontologyTree = computed(() => {
            const byCode = new Map();
            const roots = [];
            for (const item of ontologies.value) byCode.set(item.code, { ...item, children: [] });
            for (const item of ontologies.value) {
                const node = byCode.get(item.code);
                if (!node) continue;
                const parent = item.parentCode ? byCode.get(item.parentCode) : null;
                if (parent && parent.code !== node.code) parent.children.push(node);
                else roots.push(node);
            }
            const sorter = (a, b) => (a.name || "").localeCompare(b.name || "");
            const sortTree = (node) => {
                node.children.sort(sorter);
                node.children.forEach(sortTree);
            };
            roots.sort(sorter);
            roots.forEach(sortTree);
            return roots;
        });

        const filteredOntologyTree = computed(() => {
            return ontologyTree.value;
        });

        const applyTheme = (nextTheme) => {
            theme.value = nextTheme === "dark" ? "dark" : "light";
            document.documentElement.setAttribute("data-theme", theme.value);
            localStorage.setItem("uiTheme", theme.value);
        };
        const toggleTheme = () => applyTheme(theme.value === "dark" ? "light" : "dark");

        const mcpCall = async (toolName, argumentsObj = {}) => {
            const key = `${toolName}:${JSON.stringify(argumentsObj)}`;
            if (requestCache.has(key)) return requestCache.get(key);
            const task = fetch("/api/v1/mcp/graph/tools:call", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-Tenant-Id": config.tenantId,
                    "Authorization": `Bearer ${config.token}`,
                },
                body: JSON.stringify({ name: toolName, arguments: argumentsObj }),
            }).then(async (res) => {
                const payload = await res.json();
                if (!res.ok || payload.code !== 0) {
                    throw new Error(payload.message || `request failed: ${toolName}`);
                }
                const content = (((payload.data || {}).content || [])[0] || {});
                return content.json || [];
            }).catch((err) => {
                requestCache.delete(key);
                throw err;
            });
            requestCache.set(key, task);
            return task;
        };

        const getGlobalWeights = () => {
            const ws = Number(localStorage.getItem("hybrid_w_sparse") || "0.45");
            const wd = Number(localStorage.getItem("hybrid_w_dense") || "0.55");
            if (!Number.isFinite(ws) || !Number.isFinite(wd) || ws < 0 || wd < 0 || (ws + wd) <= 0) {
                return { w_sparse: 0.45, w_dense: 0.55 };
            }
            return { w_sparse: ws, w_dense: wd };
        };
        const getGlobalSearchLimits = () => {
            const topN = Number(localStorage.getItem("hybrid_top_n") || "200");
            const scoreGap = Number(localStorage.getItem("hybrid_score_gap") || "0");
            const normalizedTopN = Number.isFinite(topN) ? Math.max(1, Math.min(500, Math.floor(topN))) : 200;
            const normalizedScoreGap = Number.isFinite(scoreGap) ? Math.max(0, scoreGap) : 0;
            return { top_n: normalizedTopN, score_gap: normalizedScoreGap };
        };

        const loadDataAttributes = async () => {
            const attrs = await mcpCall("graph.list_data_attributes", {
                query: (search.dataAttributes || "").trim() || undefined,
                ...getGlobalWeights(),
                ...getGlobalSearchLimits(),
            });
            dataAttributes.value = attrs || [];
        };

        const loadOntologies = async () => {
            const classes = await mcpCall("graph.list_ontologies", {
                query: (search.ontologies || "").trim() || undefined,
                ...getGlobalWeights(),
                ...getGlobalSearchLimits(),
            });
            ontologies.value = classes || [];
        };

        const reloadResources = async () => {
            requestCache.clear();
            await Promise.all([loadDataAttributes(), loadOntologies()]);
        };
        const searchDataAttributes = async () => {
            await loadDataAttributes();
        };
        const searchOntologies = async () => {
            await loadOntologies();
        };

        const initGraph = () => {
            const cyContainer = document.getElementById("cy");
            if (!cyContainer) return;
            cy = cytoscape({
                container: cyContainer,
                elements: [],
                wheelSensitivity: 0.18,
                style: [
                    {
                        selector: "node",
                        style: {
                            "background-color": "data(color)",
                            "shape": "data(shape)",
                            "label": "data(label)",
                            "width": "data(width)",
                            "height": "data(height)",
                            "font-size": "data(fontSize)",
                            "text-wrap": "wrap",
                            "text-max-width": "data(textMaxWidth)",
                            "text-valign": "center",
                            "text-halign": "center",
                            "font-family": "Inter, Segoe UI, sans-serif",
                            "font-weight": 600,
                            "color": "#ffffff",
                            "text-outline-width": 1,
                            "text-outline-color": "data(color)",
                            "border-width": "data(borderWidth)",
                            "border-color": "#ffffff",
                            "border-opacity": 0.5,
                            "shadow-blur": 10,
                            "shadow-color": "rgba(0,0,0,0.2)",
                            "shadow-offset-y": 2,
                            "shadow-opacity": 0.5,
                        },
                    },
                    {
                        selector: "edge",
                        style: {
                            "curve-style": "bezier",
                            "line-color": "data(color)",
                            "line-style": "data(lineStyle)",
                            "width": 2,
                            "target-arrow-shape": "triangle",
                            "target-arrow-color": "data(color)",
                            "arrow-scale": 1,
                            "label": "data(label)",
                            "font-size": 9,
                            "font-weight": 500,
                            "text-background-color": "#ffffff",
                            "text-background-opacity": 0.9,
                            "text-background-padding": 2,
                            "text-background-shape": "roundrectangle",
                            "text-margin-y": -10,
                            "color": "#475569",
                        },
                    },
                ],
                layout: { name: "cose", animate: false, fit: true, padding: 30 },
            });

            cy.on("tap", "node", (evt) => {
                const node = evt.target;
                const code = node.data("code");
                const type = node.data("type");
                const now = Date.now();
                const isDouble = tapState.id === code && now - tapState.ts < 280;
                if (isDouble) {
                    if (tapTimer) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                    }
                    tapState = { id: "", ts: 0 };
                    onNodeDoubleClick(code, type);
                    return;
                }
                tapState = { id: code, ts: now };
                if (tapTimer) clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    openDetailModal(type, graphNodes.get(code) || { code, name: code });
                    tapTimer = null;
                }, 280);
            });

            cy.on("mouseover", "node", (evt) => {
                const item = graphNodes.get(evt.target.data("code"));
                const desc = (item && item.description) || "";
                if (!desc || !tooltip.value) return;
                const pos = evt.renderedPosition || { x: 0, y: 0 };
                tooltip.value.classList.remove("hidden");
                tooltip.value.style.left = `${Math.min(pos.x + 18, window.innerWidth - 380)}px`;
                tooltip.value.style.top = `${Math.max(pos.y - 8, 80)}px`;
                const content = tooltip.value.querySelector(".tooltip-content");
                if (content) content.textContent = desc;
            });
            cy.on("mouseout", "node", () => {
                if (tooltip.value) tooltip.value.classList.add("hidden");
            });
        };

        const edgePairKey = (a, b) => `${a}->${b}`;
        const edgeStyleByRelation = (sourceCode, targetCode, relationType = "") => {
            if (relationType === "inheritance") return { color: "#9ca3af", lineStyle: "dashed" };
            if (relationType === "inherited") {
                const sourceType = graphNodes.get(sourceCode)?.type;
                const targetType = graphNodes.get(targetCode)?.type;
                const pair = new Set([sourceType, targetType]);
                if (pair.has("ontology") && pair.has("dataAttribute")) return { color: "#fb923c", lineStyle: "dashed" };
                if (pair.has("ontology") && pair.has("objectProperty")) return { color: "#6366f1", lineStyle: "dashed" };
                if (pair.has("ontology") && pair.has("capability")) return { color: "#fda4af", lineStyle: "dashed" };
                return { color: "#94a3b8", lineStyle: "dashed" };
            }
            const sourceType = graphNodes.get(sourceCode)?.type;
            const targetType = graphNodes.get(targetCode)?.type;
            const pair = new Set([sourceType, targetType]);
            if (pair.has("ontology") && pair.has("dataAttribute")) return { color: "#fb923c", lineStyle: "solid" };
            if (pair.has("ontology") && pair.has("objectProperty")) return { color: "#6366f1", lineStyle: "solid" };
            if (pair.has("ontology") && pair.has("capability")) return { color: "#fda4af", lineStyle: "solid" };
            return { color: "#94a3b8", lineStyle: "solid" };
        };
        const mergeLabels = (existing, incoming) => {
            const all = new Set();
            for (const part of String(existing || "").split("|").map(s => s.trim()).filter(Boolean)) all.add(part);
            for (const part of String(incoming || "").split("|").map(s => s.trim()).filter(Boolean)) all.add(part);
            return Array.from(all).join(" | ");
        };
        const addEdge = (sourceCode, targetCode, label = "", relationType = "") => {
            if (!graphNodes.has(sourceCode) || !graphNodes.has(targetCode)) return false;
            const key = edgePairKey(sourceCode, targetCode);
            const style = edgeStyleByRelation(sourceCode, targetCode, relationType);
            if (graphEdges.has(key)) {
                const existing = graphEdges.get(key);
                const mergedLabel = mergeLabels(existing.label, label);
                const colorChanged = existing.color !== style.color || existing.lineStyle !== style.lineStyle;
                if (mergedLabel !== (existing.label || "") || colorChanged) {
                    existing.label = mergedLabel;
                    existing.color = style.color;
                    existing.lineStyle = style.lineStyle;
                    const edge = cy.getElementById(existing.id);
                    if (edge && edge.length > 0) {
                        edge.data("label", mergedLabel);
                        edge.data("color", style.color);
                        edge.data("lineStyle", style.lineStyle);
                    }
                    return true;
                }
                return false;
            }
            const id = `edge_${graphEdges.size + 1}_${Date.now()}`;
            graphEdges.set(key, {
                id,
                source: sourceCode,
                target: targetCode,
                label: String(label || ""),
                color: style.color,
                lineStyle: style.lineStyle,
            });
            cy.add({
                group: "edges",
                data: {
                    id,
                    source: sourceCode,
                    target: targetCode,
                    label: String(label || ""),
                    color: style.color,
                    lineStyle: style.lineStyle,
                },
            });
            return true;
        };

        const addNode = (type, item) => {
            const code = item.code;
            if (!code || graphNodes.has(code)) return false;
            const cfg = nodeConfig[type];
            if (!cfg) return false;
            graphNodes.set(code, { ...item, type });
            cy.add({
                group: "nodes",
                data: {
                    id: code,
                    type,
                    code,
                    name: item.name || code,
                    description: item.description || "",
                    label: `${item.name || code}\n(${code})`,
                    color: cfg.color,
                    shape: cfg.shape,
                    width: cfg.width,
                    height: cfg.height,
                    fontSize: cfg.fontSize,
                    textMaxWidth: cfg.textMaxWidth,
                    borderWidth: cfg.borderWidth,
                },
            });
            return true;
        };

        const runLayout = () => {
            cy.layout({ name: "cose", animate: true, animationDuration: 260, fit: true, padding: 35 }).run();
        };

        const ensureAttributeRelations = async (attributeCode) => {
            if (attributeOntologyCache.has(attributeCode)) return attributeOntologyCache.get(attributeCode);
            const rows = await mcpCall("graph.get_data_attribute_related_ontologies", { attributeCodes: [attributeCode] });
            const item = (rows || [])[0] || { ontologies: [] };
            attributeOntologyCache.set(attributeCode, item.ontologies || []);
            return item.ontologies || [];
        };

        const ensureOntologyRelated = async (ontologyCode) => {
            if (ontologyRelatedCache.has(ontologyCode)) return ontologyRelatedCache.get(ontologyCode);
            const rows = await mcpCall("graph.get_ontology_related_resources", { ontologyCodes: [ontologyCode] });
            const item = (rows || [])[0] || { dataAttributes: [], objectProperties: [], capabilities: [] };
            ontologyRelatedCache.set(ontologyCode, item);
            return item;
        };

        const connectOntologyHierarchyFor = (ontologyCode) => {
            const current = ontologies.value.find(item => item.code === ontologyCode);
            if (!current) return;
            if (current.parentCode && graphNodes.has(current.parentCode)) {
                addEdge(current.parentCode, ontologyCode, "", "inheritance");
            }
            for (const item of ontologies.value) {
                if (item.parentCode === ontologyCode && graphNodes.has(item.code)) {
                    addEdge(ontologyCode, item.code, "", "inheritance");
                }
            }
        };

        const connectByExistingRules = async (type, code) => {
            if (type === "dataAttribute") {
                const ontologiesForAttr = await ensureAttributeRelations(code);
                for (const ontology of ontologiesForAttr) {
                    if (graphNodes.has(ontology.code)) addEdge(ontology.code, code);
                }
            }
            if (type === "ontology") {
                const related = await ensureOntologyRelated(code);
                connectOntologyHierarchyFor(code);
                for (const attr of related.dataAttributes || []) {
                    const existingAttrs = attributeOntologyCache.get(attr.code) || [];
                    if (!existingAttrs.some(item => item.code === code)) {
                        attributeOntologyCache.set(attr.code, [...existingAttrs, related.ontology].filter(Boolean));
                    }
                    if (graphNodes.has(attr.code)) {
                        const inherited = attr.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        addEdge(code, attr.code, sourceLabel, inherited ? "inherited" : "");
                    }
                }
                for (const obj of related.objectProperties || []) {
                    if (graphNodes.has(obj.code)) {
                        const inherited = obj.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        const roles = obj.roles || [];
                        if (roles.includes("domain")) addEdge(code, obj.code, `${sourceLabel} | domain`, inherited ? "inherited" : "");
                        if (roles.includes("range")) addEdge(obj.code, code, `${sourceLabel} | range`, inherited ? "inherited" : "");
                    }
                }
                for (const cap of related.capabilities || []) {
                    if (graphNodes.has(cap.code)) {
                        const inherited = cap.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        addEdge(code, cap.code, sourceLabel, inherited ? "inherited" : "");
                    }
                }
            }
        };

        const addResourceToGraph = async (type, item) => {
            const added = addNode(type, item);
            await connectByExistingRules(type, item.code);
            if (added) runLayout();
        };

        const fetchDetailByType = async (type, code) => {
            const cacheKey = `${type}:${code}`;
            if (detailCache.has(cacheKey)) return detailCache.get(cacheKey);
            let data = null;
            if (type === "ontology") data = (await mcpCall("graph.get_ontology_details", { ontologyCodes: [code] }))[0] || null;
            if (type === "dataAttribute") data = (await mcpCall("graph.get_data_attribute_details", { attributeCodes: [code] }))[0] || null;
            if (type === "objectProperty") data = (await mcpCall("graph.get_object_property_details", { objectPropertyCodes: [code] }))[0] || null;
            if (type === "capability") data = (await mcpCall("graph.get_capability_details", { capabilityCodes: [code] }))[0] || null;
            detailCache.set(cacheKey, data);
            return data;
        };

        const openDetailModal = async (type, item) => {
            detailModal.open = true;
            detailModal.loading = true;
            detailModal.type = type;
            detailModal.basic = item;
            detailModal.title = `${item.name || item.code} (${type})`;
            detailModal.code = item.code || "";
            try {
                detailModal.detail = await fetchDetailByType(type, item.code);
            } finally {
                detailModal.loading = false;
            }
        };

        const closeDetailModal = () => {
            detailModal.open = false;
            detailModal.loading = false;
            detailModal.type = "";
            detailModal.title = "";
            detailModal.code = "";
            detailModal.basic = null;
            detailModal.detail = null;
        };

        const addFromModal = async () => {
            if (!detailModal.basic || !detailModal.type) return;
            await addResourceToGraph(detailModal.type, detailModal.basic);
        };

        const onNodeDoubleClick = async (code, type) => {
            if (type === "dataAttribute") {
                const ontologiesForAttr = await ensureAttributeRelations(code);
                let changed = false;
                for (const ontology of ontologiesForAttr) {
                    changed = addNode("ontology", ontology) || changed;
                    changed = addEdge(ontology.code, code) || changed;
                }
                if (changed) runLayout();
                return;
            }

            if (type === "ontology") {
                const related = await ensureOntologyRelated(code);
                let changed = false;
                for (const parent of related.parentOntologies || []) {
                    changed = addNode("ontology", parent) || changed;
                    changed = addEdge(parent.code, code, "", "inheritance") || changed;
                }
                for (const child of related.childOntologies || []) {
                    changed = addNode("ontology", child) || changed;
                    changed = addEdge(code, child.code, "", "inheritance") || changed;
                }
                for (const attr of related.dataAttributes || []) {
                    changed = addNode("dataAttribute", attr) || changed;
                    const inherited = attr.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    changed = addEdge(code, attr.code, sourceLabel, inherited ? "inherited" : "") || changed;
                }
                for (const obj of related.objectProperties || []) {
                    changed = addNode("objectProperty", obj) || changed;
                    const inherited = obj.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    const roles = obj.roles || [];
                    if (roles.includes("domain")) changed = addEdge(code, obj.code, `${sourceLabel} | domain`, inherited ? "inherited" : "") || changed;
                    if (roles.includes("range")) changed = addEdge(obj.code, code, `${sourceLabel} | range`, inherited ? "inherited" : "") || changed;
                }
                for (const cap of related.capabilities || []) {
                    changed = addNode("capability", cap) || changed;
                    const inherited = cap.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    changed = addEdge(code, cap.code, sourceLabel, inherited ? "inherited" : "") || changed;
                }
                connectOntologyHierarchyFor(code);
                if (changed) runLayout();
                return;
            }

            if (type === "objectProperty") {
                const detail = await fetchDetailByType("objectProperty", code);
                const domains = Array.isArray(detail?.domain) ? detail.domain : [];
                const ranges = Array.isArray(detail?.range) ? detail.range : [];
                let changed = false;
                for (const domain of domains) {
                    changed = addNode("ontology", domain) || changed;
                    changed = addEdge(domain.code, code, "domain") || changed;
                }
                for (const range of ranges) {
                    changed = addNode("ontology", range) || changed;
                    changed = addEdge(code, range.code, "range") || changed;
                }
                if (changed) runLayout();
                return;
            }

            if (type === "capability") {
                const detail = await fetchDetailByType("capability", code);
                let changed = false;
                for (const group of detail?.domain || []) {
                    for (const ontology of group.ontologies || []) {
                        changed = addNode("ontology", ontology) || changed;
                        changed = addEdge(ontology.code, code, group.groupName || "group") || changed;
                    }
                }
                if (changed) runLayout();
            }
        };

        const fitGraph = () => {
            if (!cy) return;
            cy.fit(undefined, 40);
        };

        const clearGraph = () => {
            graphNodes.clear();
            graphEdges.clear();
            if (cy) cy.elements().remove();
        };

        onMounted(async () => {
            applyTheme(theme.value);
            initGraph();
            await reloadResources();
        });

        return {
            config,
            sections,
            search,
            dataAttributes,
            ontologies,
            detailModal,
            tooltip,
            prettyDetail,
            filteredDataAttributes,
            filteredOntologyTree,
            isDarkTheme,
            toggleTheme,
            reloadResources,
            searchDataAttributes,
            searchOntologies,
            openDetailModal,
            closeDetailModal,
            addFromModal,
            addResourceToGraph,
            fitGraph,
            clearGraph,
        };
    },
}).mount("#app");
</script>
</body>
</html>
