<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Graph Workspace | TheWorld</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <style>
        [v-cloak] { display: none; }
        .workspace { height: 100vh; overflow: hidden; }
        .main-content-area { position: relative; flex: 1; overflow: hidden; }
        .cy-container { position: absolute; inset: 0; background: radial-gradient(circle at 20% 20%, #eff6ff 0%, #f8fafc 35%, #f1f5f9 100%); }
        [data-theme="dark"] .cy-container { background: radial-gradient(circle at 20% 20%, #111827 0%, #0b1220 35%, #0f172a 100%); }
        #cy { width: 100%; height: 100%; position: relative; z-index: 1; }
        .tree-node { margin-left: 1rem; border-left: 1px solid #cbd5e1; padding-left: 0.5rem; }
        [data-theme="dark"] .tree-node { border-left-color: #334155; }
        .tooltip-box { position: absolute; z-index: 50; pointer-events: none; max-width: 360px; }

        .sidebar-section { display: flex; flex-direction: column; overflow: hidden; transition: flex 0.3s ease; }
        .sidebar-section.expanded { flex: 1; }
        .sidebar-section.collapsed { flex: 0 0 auto; }

        .drawer-panel {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 40;
            display: flex;
            flex-direction: column;
            background-color: oklch(var(--b1));
            box-shadow: 0 0 25px rgba(0,0,0,0.15);
            transition: transform 0.3s ease-in-out;
        }
        .drawer-panel.left { left: 0; border-right: 1px solid oklch(var(--b2)); }
        .drawer-panel.right { right: 0; border-left: 1px solid oklch(var(--b2)); }
        .drawer-panel.left.collapsed { transform: translateX(-100%); }
        .drawer-panel.right.collapsed { transform: translateX(100%); }

        .drawer-resizer {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: col-resize;
            z-index: 50;
        }
        .drawer-resizer.left { right: -4px; }
        .drawer-resizer.right { left: -4px; }
        .drawer-resizer:hover { background: oklch(var(--p) / 0.2); }
        .drawer-resizer.resizing { background: oklch(var(--p) / 0.2); }
    </style>
</head>
<body class="bg-base-100 text-base-content antialiased">
<div id="app" v-cloak class="workspace flex flex-col">
    <header class="h-12 border-b flex items-center justify-between px-4 bg-base-100 z-30 shadow-sm shrink-0">
        <div class="flex items-center gap-3">
            <span class="font-bold text-lg flex items-center gap-2">
                <i class="fas fa-project-diagram text-primary"></i> TheWorld <span class="text-xs opacity-50 font-mono">Graph</span>
            </span>
            <div class="divider divider-horizontal m-0"></div>
            <div class="flex gap-2">
                <input v-model="config.tenantId" class="input input-xs input-bordered w-32" placeholder="Tenant ID" />
                <input v-model="config.token" type="password" class="input input-xs input-bordered w-32" placeholder="Token" />
            </div>
        </div>
        <div class="flex items-center gap-2">
            <button class="btn btn-xs btn-ghost" @click="toggleTheme">{{ isDarkTheme ? "Light" : "Dark" }}</button>
            <button class="btn btn-xs btn-outline" @click="reloadResources">Reload</button>
            <button class="btn btn-xs btn-outline" @click="fitGraph">Fit</button>
            <button class="btn btn-xs btn-outline" @click="clearGraph">Clear</button>
        </div>
    </header>

    <div class="main-content-area">
        <section class="cy-container">
            <div id="cy"></div>
            <div ref="tooltip" class="tooltip tooltip-open tooltip-right tooltip-box hidden">
                <div class="tooltip-content bg-base-300 text-base-content rounded px-2 py-1 text-xs"></div>
            </div>
        </section>

        <div class="absolute top-2 left-2 z-20 flex gap-2">
            <button @click="ui.sidebarCollapsed = !ui.sidebarCollapsed" class="btn btn-sm btn-ghost bg-base-100/50 backdrop-blur-sm shadow">
                <i class="fas fa-bars mr-2"></i> Resources
            </button>
        </div>
        <div class="absolute top-2 right-2 z-20 flex gap-2">
            <button @click="ui.chatCollapsed = !ui.chatCollapsed" class="btn btn-sm btn-ghost bg-base-100/50 backdrop-blur-sm shadow">
                <i class="fas fa-comments mr-2"></i> Chat
            </button>
        </div>

        <aside :style="{ width: ui.sidebarWidth + 'px' }" :class="['drawer-panel left', { 'collapsed': ui.sidebarCollapsed }]">
            <!-- Data Attributes Section -->
            <div class="sidebar-section border-b" :class="sections.dataAttributes ? 'expanded' : 'collapsed'">
                <div class="flex items-center justify-between px-4 py-2 bg-base-300 cursor-pointer" @click="sections.dataAttributes = !sections.dataAttributes">
                    <span class="font-bold text-sm flex items-center gap-2">
                        <i class="fas" :class="sections.dataAttributes ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                        Data Attributes
                    </span>
                    <span class="badge badge-sm opacity-50">{{ filteredDataAttributes.length }}</span>
                </div>
                <div v-show="sections.dataAttributes" class="flex-1 flex flex-col p-3 gap-2 overflow-hidden bg-base-100">
                    <div class="flex gap-1 shrink-0">
                        <input v-model="search.dataAttributes" class="input input-sm input-bordered flex-1" placeholder="Search by name/code" />
                        <button class="btn btn-sm btn-outline" @click="searchDataAttributes">Search</button>
                    </div>
                    <div class="flex-1 overflow-auto space-y-1 pr-1">
                        <div v-for="item in filteredDataAttributes" :key="'attr-'+item.code" class="flex items-center justify-between px-2 py-1 rounded hover:bg-base-200 group">
                            <button class="text-left flex-1 truncate" @click="openDetailModal('dataAttribute', item)">
                                <span class="font-semibold text-xs">{{ item.name }}</span>
                                <span class="text-[10px] opacity-60 ml-1 font-mono">{{ item.code }}</span>
                            </button>
                            <button class="btn btn-xs btn-primary opacity-0 group-hover:opacity-100 h-6 min-h-0 px-2" @click.stop="addResourceToGraph('dataAttribute', item)">Add</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ontologies Section -->
            <div class="sidebar-section" :class="sections.ontologies ? 'expanded' : 'collapsed'">
                <div class="flex items-center justify-between px-4 py-2 bg-base-300 cursor-pointer" @click="sections.ontologies = !sections.ontologies">
                    <span class="font-bold text-sm flex items-center gap-2">
                        <i class="fas" :class="sections.ontologies ? 'fa-chevron-down' : 'fa-chevron-right'"></i>
                        Ontologies
                    </span>
                    <span class="badge badge-sm opacity-50">{{ ontologies.length }}</span>
                </div>
                <div v-show="sections.ontologies" class="flex-1 flex flex-col p-3 gap-2 overflow-hidden bg-base-100">
                    <div class="flex gap-1 shrink-0">
                        <input v-model="search.ontologies" class="input input-sm input-bordered flex-1" placeholder="Search by name/code" />
                        <button class="btn btn-sm btn-outline" @click="searchOntologies">Search</button>
                    </div>
                    <div class="flex-1 overflow-auto pr-1">
                        <div v-if="showOntologySearchResultList" class="space-y-1">
                            <div v-for="item in filteredOntologyList" :key="'ontology-list-'+item.code" class="flex items-center justify-between group px-2 py-1 rounded hover:bg-base-200 transition-colors">
                                <button class="text-left flex-1 truncate" @click="openDetailModal('ontology', item)">
                                    <span class="font-semibold text-xs">{{ item.name }}</span>
                                    <span class="text-[10px] opacity-50 ml-1 font-mono">{{ item.code }}</span>
                                </button>
                                <button class="btn btn-xs btn-primary opacity-0 group-hover:opacity-100 h-6 min-h-0 px-2" @click.stop="addResourceToGraph('ontology', item)">Add</button>
                            </div>
                        </div>
                        <div v-else v-for="node in filteredOntologyTree" :key="'tree-root-'+node.code">
                            <ontology-tree-item 
                                :node="node" 
                                @add="addResourceToGraph('ontology', $event)" 
                                @detail="openDetailModal('ontology', $event)">
                            </ontology-tree-item>
                        </div>
                    </div>
                </div>
            </div>
            <div class="drawer-resizer left" @mousedown="startResizing('sidebar', $event)" :class="{ 'resizing': ui.resizing === 'sidebar' }"></div>
        </aside>

        <aside :style="{ width: ui.chatWidth + 'px' }" :class="['drawer-panel right', { 'collapsed': ui.chatCollapsed }]">
            <div class="h-11 px-3 border-b flex items-center justify-between shrink-0">
                <div class="font-semibold text-sm flex items-center gap-2">
                    <i class="fas fa-robot text-primary"></i>
                    Graph Chat
                </div>
                <div class="flex items-center gap-1">
                    <button class="btn btn-xs btn-ghost" :disabled="!chat.sessionId" @click="openAuditModal">Audit</button>
                </div>
            </div>
            <div class="px-3 py-2 border-b space-y-2 shrink-0">
                <label class="label cursor-pointer justify-start gap-2 p-0">
                    <input type="checkbox" class="checkbox checkbox-xs" v-model="chat.attachGraphContext" />
                    <span class="label-text text-xs">Send selected graph context</span>
                </label>
                <div class="text-[11px] opacity-70">
                    Session: <span class="font-mono">{{ chat.sessionId || "-" }}</span>
                </div>
                <div class="text-[11px] opacity-70">
                    Context nodes: <span class="font-mono">{{ graphContextPreview.nodeCount }}</span>
                </div>
            </div>
            <div class="flex-1 overflow-auto px-3 py-2 space-y-2">
                <div v-for="msg in chat.messages" :key="msg.id" class="rounded p-2 text-xs" :class="msg.role === 'user' ? 'bg-primary text-primary-content ml-5' : 'bg-base-200 mr-5'">
                    <div class="font-semibold mb-1">{{ msg.role === 'user' ? 'You' : 'Assistant' }}</div>
                    <div class="whitespace-pre-wrap break-words">{{ msg.content }}</div>
                </div>
                <div v-if="chat.loading" class="text-xs opacity-70 flex items-center gap-2">
                    <span class="loading loading-spinner loading-xs"></span> reasoning...
                </div>
            </div>
            <div class="p-3 border-t shrink-0">
                <div class="flex gap-2">
                    <textarea v-model="chat.input" class="textarea textarea-sm textarea-bordered flex-1" rows="2" placeholder="Ask with graph context..."></textarea>
                    <button class="btn btn-sm btn-primary" :disabled="chat.loading" @click="sendChat">
                        Send
                    </button>
                </div>
            </div>
            <div class="drawer-resizer right" @mousedown="startResizing('chat', $event)" :class="{ 'resizing': ui.resizing === 'chat' }"></div>
        </aside>
    </div>

    <dialog class="modal" :class="{ 'modal-open': detailModal.open }">
        <div class="modal-box max-w-3xl">
            <h3 class="font-bold text-lg">{{ detailModal.title }}</h3>
            <p class="text-xs opacity-60 mb-3">{{ detailModal.code }}</p>
            <div v-if="detailModal.loading" class="py-8 text-center"><span class="loading loading-spinner loading-md"></span></div>
            <div v-else class="space-y-3">
                <div class="p-3 rounded bg-base-200 overflow-auto text-sm">
                    <pre>{{ prettyDetail }}</pre>
                </div>
                <div class="modal-action">
                    <button class="btn btn-primary" @click="addFromModal">Add to Graph</button>
                    <button class="btn" @click="closeDetailModal">Close</button>
                </div>
            </div>
        </div>
    </dialog>

    <dialog class="modal" :class="{ 'modal-open': auditTrail.open }">
        <div class="modal-box max-w-5xl">
            <div class="flex items-center justify-between">
                <h3 class="font-bold text-lg">Chat Audit Timeline</h3>
                <div class="flex items-center gap-2">
                    <span class="text-xs opacity-60">Session: {{ chat.sessionId || "-" }}</span>
                    <button class="btn btn-xs btn-outline" :disabled="auditTrail.loading || !chat.sessionId" @click="loadAuditTrail">Refresh</button>
                    <button class="btn btn-xs" @click="closeAuditModal">Close</button>
                </div>
            </div>
            <div class="mt-3 p-2 rounded bg-base-200 text-xs">
                <label class="mr-2">Filter</label>
                <select v-model="auditTrail.filter" class="select select-xs select-bordered w-60">
                    <option value="">(all)</option>
                    <option value="llm_prompt_sent">llm_prompt_sent</option>
                    <option value="llm_response_received">llm_response_received</option>
                    <option value="mcp_call_requested">mcp_call_requested</option>
                    <option value="mcp_call_completed">mcp_call_completed</option>
                </select>
            </div>
            <div class="mt-3 max-h-[70vh] overflow-auto space-y-2">
                <div v-if="auditTrail.loading" class="text-xs opacity-70"><span class="loading loading-spinner loading-xs"></span> loading...</div>
                <div v-else-if="filteredAuditItems.length === 0" class="text-xs opacity-60">No audit events.</div>
                <details v-for="item in filteredAuditItems" :key="'audit-'+item.id" class="collapse collapse-arrow border border-base-300 bg-base-100">
                    <summary class="collapse-title text-xs py-2 min-h-0">
                        <span class="font-mono mr-2">#{{ item.id }}</span>
                        <span class="badge badge-xs mr-2">{{ item.step }}</span>
                        <span class="font-semibold mr-2">{{ item.event_type }}</span>
                        <span class="opacity-60">{{ item.created_at }}</span>
                    </summary>
                    <div class="collapse-content">
                        <pre class="text-[11px] whitespace-pre-wrap break-words bg-base-200 p-2 rounded">{{ stringifyAuditPayload(item.payload) }}</pre>
                    </div>
                </details>
            </div>
        </div>
    </dialog>
</div>

<script>
const { createApp, ref, reactive, computed, watch, onMounted, nextTick } = Vue;

const OntologyTreeItem = {
    name: 'OntologyTreeItem',
    props: ['node'],
    emits: ['add', 'detail'],
    setup(props) {
        const expanded = ref(false);
        return { expanded };
    },
    template: `
        <div class="select-none">
            <div class="flex items-center justify-between group px-1 py-0.5 rounded hover:bg-base-200 transition-colors">
                <div class="flex items-center gap-1 flex-1 min-w-0">
                    <button v-if="node.children && node.children.length" @click.stop="expanded = !expanded" class="w-4 h-4 flex items-center justify-center opacity-50 hover:opacity-100">
                        <i class="fas fa-xs" :class="expanded ? 'fa-minus-square' : 'fa-plus-square'"></i>
                    </button>
                    <span v-else class="w-4"></span>
                    <button class="text-left flex-1 truncate" @click="$emit('detail', node)">
                        <span class="font-semibold text-xs">{{ node.name }}</span>
                        <span class="text-[10px] opacity-50 ml-1 font-mono">{{ node.code }}</span>
                    </button>
                </div>
                <button class="btn btn-xs btn-primary opacity-0 group-hover:opacity-100 h-6 min-h-0 px-2" @click.stop="$emit('add', node)">Add</button>
            </div>
            <div v-if="expanded && node.children && node.children.length" class="tree-node">
                <ontology-tree-item v-for="child in node.children" :key="child.code" :node="child" @add="$emit('add', $event)" @detail="$emit('detail', $event)"></ontology-tree-item>
            </div>
        </div>
    `
};

createApp({
    components: { OntologyTreeItem },
    setup() {
        const theme = ref(localStorage.getItem("uiTheme") || "light");
        const isDarkTheme = computed(() => theme.value === "dark");
        const config = reactive({
            tenantId: localStorage.getItem("tenantId") || "tenant-a",
            token: localStorage.getItem("token") || "test-token",
        });
        const ui = reactive({
            sidebarWidth: Number(localStorage.getItem("graphSidebarWidth")) || 400,
            chatWidth: Number(localStorage.getItem("graphChatWidth")) || 360,
            sidebarCollapsed: false,
            chatCollapsed: false,
            resizing: null,
        });
        const chat = reactive({
            attachGraphContext: true,
            sessionId: "",
            awaitingClarification: false,
            input: "",
            loading: false,
            messages: [],
        });
        const tenantSearchConfig = reactive({
            word_w_sparse: 0.45,
            word_w_dense: 0.55,
            sentence_w_sparse: 0.25,
            sentence_w_dense: 0.75,
            top_n: 200,
            score_gap: 0,
            relative_diff: 0,
        });

        const sections = reactive({ dataAttributes: true, ontologies: true });
        const search = reactive({ dataAttributes: "", ontologies: "" });
        const dataAttributes = ref([]);
        const ontologies = ref([]);
        const ontologySearchQuery = ref("");
        const detailModal = reactive({ open: false, loading: false, type: "", title: "", code: "", basic: null, detail: null });
        const auditTrail = reactive({ open: false, loading: false, items: [], filter: "" });

        const requestCache = new Map();
        const detailCache = new Map();
        const ontologyRelatedCache = new Map();
        const attributeOntologyCache = new Map();

        let cy = null;
        const lastFocusedNodeCode = ref("");
        const graphNodes = new Map();
        const graphEdges = new Map();
        const tooltip = ref(null);
        let tapState = { id: "", ts: 0 };
        let tapTimer = null;

        const nodeConfig = {
            ontology: { shape: "roundrectangle", color: "#3b82f6", width: 220, height: 74, fontSize: 13, textMaxWidth: 170, borderWidth: 4 },
            dataAttribute: { shape: "ellipse", color: "#f59e0b", width: 72, height: 72, fontSize: 8, textMaxWidth: 80, borderWidth: 2 },
            objectProperty: { shape: "diamond", color: "#8b5cf6", width: 68, height: 68, fontSize: 8, textMaxWidth: 76, borderWidth: 2 },
            capability: { shape: "hexagon", color: "#ef4444", width: 68, height: 68, fontSize: 8, textMaxWidth: 76, borderWidth: 2 },
        };

        const prettyDetail = computed(() => JSON.stringify(detailModal.detail || {}, null, 2));
        const filteredAuditItems = computed(() => {
            if (!auditTrail.filter) return auditTrail.items;
            return auditTrail.items.filter((item) => item.event_type === auditTrail.filter);
        });

        const filteredDataAttributes = computed(() => {
            return dataAttributes.value;
        });

        const ontologyTree = computed(() => {
            const byCode = new Map();
            const roots = [];
            for (const item of ontologies.value) byCode.set(item.code, { ...item, children: [] });
            for (const item of ontologies.value) {
                const node = byCode.get(item.code);
                if (!node) continue;
                const parent = item.parentCode ? byCode.get(item.parentCode) : null;
                if (parent && parent.code !== node.code) parent.children.push(node);
                else roots.push(node);
            }
            const sorter = (a, b) => (a.name || "").localeCompare(b.name || "");
            const sortTree = (node) => {
                node.children.sort(sorter);
                node.children.forEach(sortTree);
            };
            roots.sort(sorter);
            roots.forEach(sortTree);
            return roots;
        });

        const filteredOntologyTree = computed(() => {
            return ontologyTree.value;
        });
        const showOntologySearchResultList = computed(() => !!(ontologySearchQuery.value || "").trim());
        const filteredOntologyList = computed(() => {
            if (!showOntologySearchResultList.value) return [];
            return ontologies.value;
        });

        const applyTheme = (nextTheme) => {
            theme.value = nextTheme === "dark" ? "dark" : "light";
            document.documentElement.setAttribute("data-theme", theme.value);
            localStorage.setItem("uiTheme", theme.value);
        };
        const toggleTheme = () => applyTheme(theme.value === "dark" ? "light" : "dark");

        const mcpCall = async (toolName, argumentsObj = {}) => {
            const key = `${config.tenantId}:${toolName}:${JSON.stringify(argumentsObj)}`;
            if (requestCache.has(key)) return requestCache.get(key);
            const task = fetch("/api/v1/mcp/graph/tools:call", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-Tenant-Id": config.tenantId,
                    "Authorization": `Bearer ${config.token}`,
                },
                body: JSON.stringify({ name: toolName, arguments: argumentsObj }),
            }).then(async (res) => {
                const payload = await res.json();
                if (!res.ok || payload.code !== 0) {
                    throw new Error(payload.message || `request failed: ${toolName}`);
                }
                const content = (((payload.data || {}).content || [])[0] || {});
                return content.json || [];
            }).catch((err) => {
                requestCache.delete(key);
                throw err;
            });
            requestCache.set(key, task);
            return task;
        };

        const countQueryTokens = (query) => {
            const q = String(query || "").trim().toLowerCase();
            if (!q) return 0;
            const spaced = q.split(/\s+/).filter(Boolean);
            if (spaced.length > 1) return spaced.length;
            const cjk = q.match(/[\u4e00-\u9fff]/g);
            if (cjk && cjk.length) return cjk.length;
            return 1;
        };
        const getGlobalWeights = (query) => {
            const tokenCount = countQueryTokens(query);
            const ws = tokenCount <= 2
                ? Number(tenantSearchConfig.word_w_sparse)
                : Number(tenantSearchConfig.sentence_w_sparse);
            const wd = tokenCount <= 2
                ? Number(tenantSearchConfig.word_w_dense)
                : Number(tenantSearchConfig.sentence_w_dense);
            if (!Number.isFinite(ws) || !Number.isFinite(wd) || ws < 0 || wd < 0 || (ws + wd) <= 0) {
                return { w_sparse: 0.45, w_dense: 0.55 };
            }
            return { w_sparse: ws, w_dense: wd };
        };
        const getGlobalSearchLimits = () => {
            const topN = Number(tenantSearchConfig.top_n);
            const scoreGap = Number(tenantSearchConfig.score_gap);
            const relativeDiff = Number(tenantSearchConfig.relative_diff);
            const normalizedTopN = Number.isFinite(topN) ? Math.max(1, Math.min(500, Math.floor(topN))) : 200;
            const normalizedScoreGap = Number.isFinite(scoreGap) ? Math.max(0, scoreGap) : 0;
            const normalizedRelativeDiff = Number.isFinite(relativeDiff) ? Math.max(0, relativeDiff) : 0;
            return { top_n: normalizedTopN, score_gap: normalizedScoreGap, relative_diff: normalizedRelativeDiff };
        };

        const loadDataAttributes = async () => {
            const query = (search.dataAttributes || "").trim();
            const attrsPayload = await mcpCall("graph.list_data_attributes", {
                query: query || undefined,
                ...getGlobalWeights(query),
                ...getGlobalSearchLimits(),
            });
            const attrs = Array.isArray(attrsPayload) ? attrsPayload : (attrsPayload.items || []);
            dataAttributes.value = attrs || [];
        };

        const loadOntologies = async () => {
            const query = (search.ontologies || "").trim();
            const classesPayload = await mcpCall("graph.list_ontologies", {
                query: query || undefined,
                ...getGlobalWeights(query),
                ...getGlobalSearchLimits(),
            });
            ontologySearchQuery.value = String((classesPayload && classesPayload.query) || query || "");
            const classes = Array.isArray(classesPayload) ? classesPayload : (classesPayload.items || []);
            ontologies.value = classes || [];
        };

        const reloadResources = async () => {
            requestCache.clear();
            await Promise.all([loadDataAttributes(), loadOntologies()]);
        };
        const searchDataAttributes = async () => {
            await loadDataAttributes();
        };
        const searchOntologies = async () => {
            await loadOntologies();
        };

        const initGraph = () => {
            const cyContainer = document.getElementById("cy");
            if (!cyContainer) return;
            cy = cytoscape({
                container: cyContainer,
                elements: [],
                wheelSensitivity: 0.18,
                style: [
                    {
                        selector: "node",
                        style: {
                            "background-color": "data(color)",
                            "shape": "data(shape)",
                            "label": "data(label)",
                            "width": "data(width)",
                            "height": "data(height)",
                            "font-size": "data(fontSize)",
                            "text-wrap": "wrap",
                            "text-max-width": "data(textMaxWidth)",
                            "text-valign": "center",
                            "text-halign": "center",
                            "font-family": "Inter, Segoe UI, sans-serif",
                            "font-weight": 600,
                            "color": "#ffffff",
                            "text-outline-width": 1,
                            "text-outline-color": "data(color)",
                            "border-width": "data(borderWidth)",
                            "border-color": "#ffffff",
                            "border-opacity": 0.5,
                            "shadow-blur": 10,
                            "shadow-color": "rgba(0,0,0,0.2)",
                            "shadow-offset-y": 2,
                            "shadow-opacity": 0.5,
                        },
                    },
                    {
                        selector: "edge",
                        style: {
                            "curve-style": "bezier",
                            "line-color": "data(color)",
                            "line-style": "data(lineStyle)",
                            "width": 2,
                            "target-arrow-shape": "triangle",
                            "target-arrow-color": "data(color)",
                            "arrow-scale": 1,
                            "label": "data(label)",
                            "font-size": 9,
                            "font-weight": 500,
                            "text-background-color": "#ffffff",
                            "text-background-opacity": 0.9,
                            "text-background-padding": 2,
                            "text-background-shape": "roundrectangle",
                            "text-margin-y": -10,
                            "color": "#475569",
                        },
                    },
                ],
                layout: { name: "cose", animate: false, fit: true, padding: 30 },
            });

            cy.on("tap", "node", (evt) => {
                const node = evt.target;
                const code = node.data("code");
                const type = node.data("type");
                lastFocusedNodeCode.value = code;
                const now = Date.now();
                const isDouble = tapState.id === code && now - tapState.ts < 280;
                if (isDouble) {
                    if (tapTimer) {
                        clearTimeout(tapTimer);
                        tapTimer = null;
                    }
                    tapState = { id: "", ts: 0 };
                    onNodeDoubleClick(code, type);
                    return;
                }
                tapState = { id: code, ts: now };
                if (tapTimer) clearTimeout(tapTimer);
                tapTimer = setTimeout(() => {
                    openDetailModal(type, graphNodes.get(code) || { code, name: code });
                    tapTimer = null;
                }, 280);
            });

            cy.on("mouseover", "node", (evt) => {
                const item = graphNodes.get(evt.target.data("code"));
                const desc = (item && item.description) || "";
                if (!desc || !tooltip.value) return;
                const pos = evt.renderedPosition || { x: 0, y: 0 };
                tooltip.value.classList.remove("hidden");
                tooltip.value.style.left = `${Math.min(pos.x + 18, window.innerWidth - 380)}px`;
                tooltip.value.style.top = `${Math.max(pos.y - 8, 80)}px`;
                const content = tooltip.value.querySelector(".tooltip-content");
                if (content) content.textContent = desc;
            });
            cy.on("mouseout", "node", () => {
                if (tooltip.value) tooltip.value.classList.add("hidden");
            });
        };

        const edgePairKey = (a, b) => `${a}->${b}`;
        const edgeStyleByRelation = (sourceCode, targetCode, relationType = "") => {
            if (relationType === "inheritance") return { color: "#9ca3af", lineStyle: "dashed" };
            if (relationType === "inherited") {
                const sourceType = graphNodes.get(sourceCode)?.type;
                const targetType = graphNodes.get(targetCode)?.type;
                const pair = new Set([sourceType, targetType]);
                if (pair.has("ontology") && pair.has("dataAttribute")) return { color: "#fb923c", lineStyle: "dashed" };
                if (pair.has("ontology") && pair.has("objectProperty")) return { color: "#6366f1", lineStyle: "dashed" };
                if (pair.has("ontology") && pair.has("capability")) return { color: "#fda4af", lineStyle: "dashed" };
                return { color: "#94a3b8", lineStyle: "dashed" };
            }
            const sourceType = graphNodes.get(sourceCode)?.type;
            const targetType = graphNodes.get(targetCode)?.type;
            const pair = new Set([sourceType, targetType]);
            if (pair.has("ontology") && pair.has("dataAttribute")) return { color: "#fb923c", lineStyle: "solid" };
            if (pair.has("ontology") && pair.has("objectProperty")) return { color: "#6366f1", lineStyle: "solid" };
            if (pair.has("ontology") && pair.has("capability")) return { color: "#fda4af", lineStyle: "solid" };
            return { color: "#94a3b8", lineStyle: "solid" };
        };
        const mergeLabels = (existing, incoming) => {
            const all = new Set();
            for (const part of String(existing || "").split("|").map(s => s.trim()).filter(Boolean)) all.add(part);
            for (const part of String(incoming || "").split("|").map(s => s.trim()).filter(Boolean)) all.add(part);
            return Array.from(all).join(" | ");
        };
        const addEdge = (sourceCode, targetCode, label = "", relationType = "") => {
            if (!graphNodes.has(sourceCode) || !graphNodes.has(targetCode)) return false;
            const key = edgePairKey(sourceCode, targetCode);
            const style = edgeStyleByRelation(sourceCode, targetCode, relationType);
            if (graphEdges.has(key)) {
                const existing = graphEdges.get(key);
                const mergedLabel = mergeLabels(existing.label, label);
                const colorChanged = existing.color !== style.color || existing.lineStyle !== style.lineStyle;
                if (mergedLabel !== (existing.label || "") || colorChanged) {
                    existing.label = mergedLabel;
                    existing.color = style.color;
                    existing.lineStyle = style.lineStyle;
                    const edge = cy.getElementById(existing.id);
                    if (edge && edge.length > 0) {
                        edge.data("label", mergedLabel);
                        edge.data("color", style.color);
                        edge.data("lineStyle", style.lineStyle);
                    }
                    return true;
                }
                return false;
            }
            const id = `edge_${graphEdges.size + 1}_${Date.now()}`;
            graphEdges.set(key, {
                id,
                source: sourceCode,
                target: targetCode,
                label: String(label || ""),
                color: style.color,
                lineStyle: style.lineStyle,
            });
            cy.add({
                group: "edges",
                data: {
                    id,
                    source: sourceCode,
                    target: targetCode,
                    label: String(label || ""),
                    color: style.color,
                    lineStyle: style.lineStyle,
                },
            });
            return true;
        };

        const addNode = (type, item) => {
            const code = item.code;
            if (!code || graphNodes.has(code)) return false;
            const cfg = nodeConfig[type];
            if (!cfg) return false;
            graphNodes.set(code, { ...item, type });
            cy.add({
                group: "nodes",
                data: {
                    id: code,
                    type,
                    code,
                    name: item.name || code,
                    description: item.description || "",
                    label: `${item.name || code}\n(${code})`,
                    color: cfg.color,
                    shape: cfg.shape,
                    width: cfg.width,
                    height: cfg.height,
                    fontSize: cfg.fontSize,
                    textMaxWidth: cfg.textMaxWidth,
                    borderWidth: cfg.borderWidth,
                },
            });
            return true;
        };

        const runLayout = () => {
            cy.layout({ name: "cose", animate: true, animationDuration: 260, fit: true, padding: 35 }).run();
        };

        const ensureAttributeRelations = async (attributeCode) => {
            if (attributeOntologyCache.has(attributeCode)) return attributeOntologyCache.get(attributeCode);
            const rows = await mcpCall("graph.get_data_attribute_related_ontologies", { attributeCodes: [attributeCode] });
            const item = (rows || [])[0] || { ontologies: [] };
            attributeOntologyCache.set(attributeCode, item.ontologies || []);
            return item.ontologies || [];
        };

        const ensureOntologyRelated = async (ontologyCode) => {
            if (ontologyRelatedCache.has(ontologyCode)) return ontologyRelatedCache.get(ontologyCode);
            const rows = await mcpCall("graph.get_ontology_related_resources", { ontologyCodes: [ontologyCode] });
            const item = (rows || [])[0] || { dataAttributes: [], objectProperties: [], capabilities: [] };
            ontologyRelatedCache.set(ontologyCode, item);
            return item;
        };

        const connectOntologyHierarchyFor = (ontologyCode) => {
            const current = ontologies.value.find(item => item.code === ontologyCode);
            if (!current) return;
            if (current.parentCode && graphNodes.has(current.parentCode)) {
                addEdge(current.parentCode, ontologyCode, "", "inheritance");
            }
            for (const item of ontologies.value) {
                if (item.parentCode === ontologyCode && graphNodes.has(item.code)) {
                    addEdge(ontologyCode, item.code, "", "inheritance");
                }
            }
        };

        const connectByExistingRules = async (type, code) => {
            if (type === "dataAttribute") {
                const ontologiesForAttr = await ensureAttributeRelations(code);
                for (const ontology of ontologiesForAttr) {
                    if (graphNodes.has(ontology.code)) addEdge(ontology.code, code);
                }
            }
            if (type === "ontology") {
                const related = await ensureOntologyRelated(code);
                connectOntologyHierarchyFor(code);
                for (const attr of related.dataAttributes || []) {
                    const existingAttrs = attributeOntologyCache.get(attr.code) || [];
                    if (!existingAttrs.some(item => item.code === code)) {
                        attributeOntologyCache.set(attr.code, [...existingAttrs, related.ontology].filter(Boolean));
                    }
                    if (graphNodes.has(attr.code)) {
                        const inherited = attr.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        addEdge(code, attr.code, sourceLabel, inherited ? "inherited" : "");
                    }
                }
                for (const obj of related.objectProperties || []) {
                    if (graphNodes.has(obj.code)) {
                        const inherited = obj.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        const roles = obj.roles || [];
                        if (roles.includes("domain")) addEdge(code, obj.code, `${sourceLabel} | domain`, inherited ? "inherited" : "");
                        if (roles.includes("range")) addEdge(obj.code, code, `${sourceLabel} | range`, inherited ? "inherited" : "");
                    }
                }
                for (const cap of related.capabilities || []) {
                    if (graphNodes.has(cap.code)) {
                        const inherited = cap.bindingSource === "inherited";
                        const sourceLabel = inherited ? "inherited" : "self";
                        addEdge(code, cap.code, sourceLabel, inherited ? "inherited" : "");
                    }
                }
            }
        };

        const addResourceToGraph = async (type, item) => {
            const added = addNode(type, item);
            await connectByExistingRules(type, item.code);
            if (added) runLayout();
        };

        const fetchDetailByType = async (type, code) => {
            const cacheKey = `${type}:${code}`;
            if (detailCache.has(cacheKey)) return detailCache.get(cacheKey);
            let data = null;
            if (type === "ontology") data = (await mcpCall("graph.get_ontology_details", { ontologyCodes: [code] }))[0] || null;
            if (type === "dataAttribute") data = (await mcpCall("graph.get_data_attribute_details", { attributeCodes: [code] }))[0] || null;
            if (type === "objectProperty") data = (await mcpCall("graph.get_object_property_details", { objectPropertyCodes: [code] }))[0] || null;
            if (type === "capability") data = (await mcpCall("graph.get_capability_details", { capabilityCodes: [code] }))[0] || null;
            detailCache.set(cacheKey, data);
            return data;
        };

        const openDetailModal = async (type, item) => {
            detailModal.open = true;
            detailModal.loading = true;
            detailModal.type = type;
            detailModal.basic = item;
            detailModal.title = `${item.name || item.code} (${type})`;
            detailModal.code = item.code || "";
            try {
                detailModal.detail = await fetchDetailByType(type, item.code);
            } finally {
                detailModal.loading = false;
            }
        };

        const closeDetailModal = () => {
            detailModal.open = false;
            detailModal.loading = false;
            detailModal.type = "";
            detailModal.title = "";
            detailModal.code = "";
            detailModal.basic = null;
            detailModal.detail = null;
        };
        const stringifyAuditPayload = (payload) => {
            try {
                return JSON.stringify(payload || {}, null, 2);
            } catch (_err) {
                return String(payload || "");
            }
        };
        const loadAuditTrail = async () => {
            if (!chat.sessionId) {
                auditTrail.items = [];
                return;
            }
            auditTrail.loading = true;
            try {
                const res = await fetch(`/api/v1/reasoning/sessions/${chat.sessionId}/trace`, {
                    method: "GET",
                    headers: {
                        "X-Tenant-Id": config.tenantId,
                        "Authorization": `Bearer ${config.token}`,
                    },
                });
                const payload = await res.json();
                if (!res.ok || payload.code !== 0) {
                    throw new Error(payload.message || "load audit failed");
                }
                auditTrail.items = (((payload.data || {}).items) || []);
            } catch (_err) {
                auditTrail.items = [];
            } finally {
                auditTrail.loading = false;
            }
        };
        const openAuditModal = async () => {
            auditTrail.open = true;
            await loadAuditTrail();
        };
        const closeAuditModal = () => {
            auditTrail.open = false;
        };

        const addFromModal = async () => {
            if (!detailModal.basic || !detailModal.type) return;
            await addResourceToGraph(detailModal.type, detailModal.basic);
        };

        const onNodeDoubleClick = async (code, type) => {
            if (type === "dataAttribute") {
                const ontologiesForAttr = await ensureAttributeRelations(code);
                let changed = false;
                for (const ontology of ontologiesForAttr) {
                    changed = addNode("ontology", ontology) || changed;
                    changed = addEdge(ontology.code, code) || changed;
                }
                if (changed) runLayout();
                return;
            }

            if (type === "ontology") {
                const related = await ensureOntologyRelated(code);
                let changed = false;
                for (const parent of related.parentOntologies || []) {
                    changed = addNode("ontology", parent) || changed;
                    changed = addEdge(parent.code, code, "", "inheritance") || changed;
                }
                for (const child of related.childOntologies || []) {
                    changed = addNode("ontology", child) || changed;
                    changed = addEdge(code, child.code, "", "inheritance") || changed;
                }
                for (const attr of related.dataAttributes || []) {
                    changed = addNode("dataAttribute", attr) || changed;
                    const inherited = attr.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    changed = addEdge(code, attr.code, sourceLabel, inherited ? "inherited" : "") || changed;
                }
                for (const obj of related.objectProperties || []) {
                    changed = addNode("objectProperty", obj) || changed;
                    const inherited = obj.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    const roles = obj.roles || [];
                    if (roles.includes("domain")) changed = addEdge(code, obj.code, `${sourceLabel} | domain`, inherited ? "inherited" : "") || changed;
                    if (roles.includes("range")) changed = addEdge(obj.code, code, `${sourceLabel} | range`, inherited ? "inherited" : "") || changed;
                }
                for (const cap of related.capabilities || []) {
                    changed = addNode("capability", cap) || changed;
                    const inherited = cap.bindingSource === "inherited";
                    const sourceLabel = inherited ? "inherited" : "self";
                    changed = addEdge(code, cap.code, sourceLabel, inherited ? "inherited" : "") || changed;
                }
                connectOntologyHierarchyFor(code);
                if (changed) runLayout();
                return;
            }

            if (type === "objectProperty") {
                const detail = await fetchDetailByType("objectProperty", code);
                const domains = Array.isArray(detail?.domain) ? detail.domain : [];
                const ranges = Array.isArray(detail?.range) ? detail.range : [];
                let changed = false;
                for (const domain of domains) {
                    changed = addNode("ontology", domain) || changed;
                    changed = addEdge(domain.code, code, "domain") || changed;
                }
                for (const range of ranges) {
                    changed = addNode("ontology", range) || changed;
                    changed = addEdge(code, range.code, "range") || changed;
                }
                if (changed) runLayout();
                return;
            }

            if (type === "capability") {
                const detail = await fetchDetailByType("capability", code);
                let changed = false;
                for (const group of detail?.domain || []) {
                    for (const ontology of group.ontologies || []) {
                        changed = addNode("ontology", ontology) || changed;
                        changed = addEdge(ontology.code, code, group.groupName || "group") || changed;
                    }
                }
                if (changed) runLayout();
            }
        };

        const fitGraph = () => {
            if (!cy) return;
            cy.fit(undefined, 40);
        };

        const clearGraph = () => {
            graphNodes.clear();
            graphEdges.clear();
            if (cy) cy.elements().remove();
        };

        const resizeGraphCanvas = () => {
            if (!cy) return;
            cy.resize();
        };

        let activeResizer = null;
        let initialPos = 0;
        let initialWidth = 0;

        const startResizing = (part, event) => {
            activeResizer = part;
            initialPos = event.clientX;
            if (part === 'sidebar') initialWidth = ui.sidebarWidth;
            else if (part === 'chat') initialWidth = ui.chatWidth;

            document.addEventListener("mousemove", doResize);
            document.addEventListener("mouseup", stopResizing);
            document.body.style.userSelect = "none";
            document.body.style.cursor = "col-resize";
        };

        const doResize = (event) => {
            if (activeResizer === 'sidebar') {
                const newWidth = initialWidth + (event.clientX - initialPos);
                ui.sidebarWidth = Math.max(200, Math.min(800, newWidth));
            } else if (activeResizer === 'chat') {
                const newWidth = initialWidth - (event.clientX - initialPos);
                ui.chatWidth = Math.max(200, Math.min(800, newWidth));
            }
            if (cy) cy.resize();
        };

        const stopResizing = () => {
            if (activeResizer === 'sidebar') localStorage.setItem("graphSidebarWidth", ui.sidebarWidth);
            else if (activeResizer === 'chat') localStorage.setItem("graphChatWidth", ui.chatWidth);
            
            activeResizer = null;
            document.removeEventListener("mousemove", doResize);
            document.removeEventListener("mouseup", stopResizing);
            document.body.style.userSelect = "";
            document.body.style.cursor = "";
        };

        const graphContextPreview = computed(() => {
            let selectedCodes = [];
            if (cy) {
                selectedCodes = cy.$("node:selected").map((node) => node.data("code"));
            }
            if (!selectedCodes.length && lastFocusedNodeCode.value) {
                selectedCodes = [lastFocusedNodeCode.value];
            }
            return { nodeCount: selectedCodes.length };
        });

        const buildGraphContext = () => {
            let selectedCodes = [];
            if (cy) {
                selectedCodes = cy.$("node:selected").map((node) => node.data("code"));
            }
            if (!selectedCodes.length && lastFocusedNodeCode.value) {
                selectedCodes = [lastFocusedNodeCode.value];
            }
            const nodes = selectedCodes
                .filter((code) => graphNodes.has(code))
                .map((code) => {
                    const item = graphNodes.get(code) || {};
                    return { code, name: item.name, type: item.type };
                });
            const codeSet = new Set(nodes.map((item) => item.code));
            const edges = Array.from(graphEdges.values())
                .filter((edge) => codeSet.has(edge.source) && codeSet.has(edge.target))
                .map((edge) => ({ source: edge.source, target: edge.target, label: edge.label }));
            return { nodes, edges };
        };

        const addChatMessage = (role, content) => {
            chat.messages.push({ id: `${Date.now()}_${Math.random()}`, role, content: String(content || "") });
        };

        const apiPost = async (url, body) => {
            const res = await fetch(url, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "X-Tenant-Id": config.tenantId,
                    "Authorization": `Bearer ${config.token}`,
                },
                body: JSON.stringify(body || {}),
            });
            const payload = await res.json();
            if (!res.ok || payload.code !== 0) {
                throw new Error(payload.message || `request failed: ${url}`);
            }
            return payload.data || {};
        };
        const apiGet = async (url) => {
            const res = await fetch(url, {
                method: "GET",
                headers: {
                    "X-Tenant-Id": config.tenantId,
                    "Authorization": `Bearer ${config.token}`,
                },
            });
            const payload = await res.json();
            if (!res.ok || payload.code !== 0) {
                throw new Error(payload.message || `request failed: ${url}`);
            }
            return payload.data || {};
        };
        const loadTenantSearchConfig = async () => {
            try {
                const data = await apiGet("/api/v1/config/tenant-search-config");
                tenantSearchConfig.word_w_sparse = Number(data.word_w_sparse ?? tenantSearchConfig.word_w_sparse);
                tenantSearchConfig.word_w_dense = Number(data.word_w_dense ?? tenantSearchConfig.word_w_dense);
                tenantSearchConfig.sentence_w_sparse = Number(data.sentence_w_sparse ?? tenantSearchConfig.sentence_w_sparse);
                tenantSearchConfig.sentence_w_dense = Number(data.sentence_w_dense ?? tenantSearchConfig.sentence_w_dense);
                tenantSearchConfig.top_n = Number(data.top_n ?? tenantSearchConfig.top_n);
                tenantSearchConfig.score_gap = Number(data.score_gap ?? tenantSearchConfig.score_gap);
                tenantSearchConfig.relative_diff = Number(data.relative_diff ?? tenantSearchConfig.relative_diff);
            } catch (_err) {
            }
        };

        const runReasoning = async (userInput = null) => {
            const runData = await apiPost(`/api/v1/reasoning/sessions/${chat.sessionId}/run`, userInput ? { user_input: userInput } : {});
            if (runData.status === "waiting_clarification") {
                chat.awaitingClarification = true;
                const q = (((runData.clarification || {}).question || {}).question) || "";
                addChatMessage("assistant", q);
                return;
            }
            chat.awaitingClarification = false;
            const result = runData.result || {};
            const summary = result.summary || "";
            const mode = result.data_execution_mode ? `\nData mode: ${result.data_execution_mode}` : "";
            addChatMessage("assistant", `${summary}${mode}`);
        };

        const sendChat = async () => {
            const text = String(chat.input || "").trim();
            if (!text || chat.loading) return;
            chat.input = "";
            addChatMessage("user", text);
            chat.loading = true;
            try {
                const graphContext = chat.attachGraphContext ? buildGraphContext() : { nodes: [], edges: [] };
                if (!chat.sessionId) {
                    const created = await apiPost("/api/v1/reasoning/sessions", {
                        user_input: text,
                        metadata: { source: "graph_workspace", graph_context: graphContext },
                    });
                    chat.sessionId = created.session_id;
                    await runReasoning();
                } else if (chat.awaitingClarification) {
                    await apiPost(`/api/v1/reasoning/sessions/${chat.sessionId}/clarify`, {
                        answer: { text, graph_context: graphContext },
                    });
                    await runReasoning();
                } else {
                    await runReasoning(text);
                }
            } catch (err) {
                addChatMessage("assistant", `Error: ${err.message || err}`);
            } finally {
                chat.loading = false;
                if (auditTrail.open && chat.sessionId) await loadAuditTrail();
            }
        };

        onMounted(async () => {
            applyTheme(theme.value);
            initGraph();
            await loadTenantSearchConfig();
            await reloadResources();
        });
        watch(
            () => config.tenantId,
            async (tenantId) => {
                localStorage.setItem("tenantId", tenantId || "");
                requestCache.clear();
                detailCache.clear();
                ontologyRelatedCache.clear();
                attributeOntologyCache.clear();
                await loadTenantSearchConfig();
            },
        );
        watch(
            () => config.token,
            (token) => {
                localStorage.setItem("token", token || "");
            },
        );

        return {
            config,
            sections,
            search,
            dataAttributes,
            ontologies,
            detailModal,
            auditTrail,
            chat,
            tooltip,
            prettyDetail,
            filteredAuditItems,
            graphContextPreview,
            filteredDataAttributes,
            filteredOntologyTree,
            filteredOntologyList,
            showOntologySearchResultList,
            isDarkTheme,
            toggleTheme,
            reloadResources,
            searchDataAttributes,
            searchOntologies,
            openDetailModal,
            closeDetailModal,
            openAuditModal,
            closeAuditModal,
            loadAuditTrail,
            stringifyAuditPayload,
            addFromModal,
            addResourceToGraph,
            ui,
            startResizing,
            sendChat,
            fitGraph,
            clearGraph,
        };
    },
}).mount("#app");
</script>
</body>
</html>


